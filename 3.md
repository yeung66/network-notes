# 3 运输层

## 多路复用与多路分解

网络层提供的主机间的交互扩展到主机上应用程序进程间的交互

- 多路分解：将运输层报文交付到正确的套接字
- 多路复用：主机从套接字收集数据块并封装首部生成报文，然后传递给网络层
- 多路复用要求：套接字有唯一标识（源端口号）/指示目的套接字（目的端口号）
- 端口号16比特，0-1023为周知端口号

### 无状态多路复用与多路分解

- 建立socket时自动分配未被使用端口号
- 通过bind方法可以为套接字关联一个端口号
- 报文到达对方主机后，根据目的端口号将报文交付给相应套接字
- 每个套接字由一个（目的IP，目的端口）标识

### 面向连接多路复用与多路分解

- 每个套接字由一个（源IP，源端口，目的IP，目的端口）标识，报文根据全部4个值来定向到套接字
- 每个套接字与一个进程/线程相关联

## UDP

运输协议能做的最少工作：复用/分解+差错检测

进程获得数据，附加端口号等字段，交给网络层，对方收到后根据端口号交给相应的进程

### 使用原因

- 对于发送什么以及何时发送应用层控制更为精细
  - UDP：只用传输数据给UDP马上发送
  - 而TCP具有拥塞控制机制/实现可靠交付可能需要重复发送报文
  - 实时应用：满足最小的发送速率
- 无须建立连接：避免建立连接的时延
- 无连接状态
- 首部开销小：8字节而TCP20字节

### 报文结构

- 首部：32*2比特
  - 源端口号
  - 目的端口号
  - 长度：首部+数据
  - 检验和
- 数据

### 检验和

所有数据16比特按进位相加，溢出回卷，最后的和的反码为检验和

- 接收时将所有数据以及检验和加起来，判断是否为0xffff

#### 端对端原则

与较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或者几乎没有价值的

- 因为端对端数据传输需要提供差错检测，UDP必须在运输层的基础上提供差错检测

## 可靠数据传输原理

服务抽象：数据可以通过一条可靠信道传输，传输数据比特不会损坏或丢失，且按顺序交付

实现：可靠数据传输协议

### 构造可靠数据传输协议rdt

1. rdt1.0：信道完全可靠，数据封装成分组后直接传输，接受分组后直接获取数据进行分发
2. rdt2.0：具有比特差错 自动重传协议ARQ——接收到信息后给予反馈，有问题则重新传输
   - 协议功能：
     - 差错检测
     - 接受方反馈：ACK NAK
     - 重传
   - 停等协议：等待应答时不能发送新数据
   - 问题：应答信号也可能有差错
     - 解决：差错询问/差错恢复/rdt2.1
3. rdt2.1：为解决2.0中应答信号可能出错，采用非ACK则重复发送，并引入编号解决冗余分组
   - 发送方：
     - 被调用发送数据时，发送编号，数据，检验和，进入等待应答状态
     - 当收到应答分组有误或为NAK则重发
     - 否则进入下一编号等待调用阶段
   - 接收方：
     - 当接受到数据分组没有错误且编号为0时，获取数据，返回ACK，检验和，进入下一编号状态
     - 若数据分组有误，则返回NAK和检验和
     - 若数据没有错误但编号异常，则返回ACK和检验和，不获取数据
4. rdt2.2：无NAK版本的2.1，通过判断应答分组是否ACK且编号正确判断需否重发
   - 发送方：
     - 被调用发送数据时，发送编号，数据，检验和，进入等待应答状态
     - 当收到应答分组有误或编号不对则重发
     - 否则进入下一编号等待调用阶段
   - 接收方：
     - 当接受到数据分组没有错误且编号为0时，获取数据，返回ACK，检验和与编号0，进入下一编号状态
     - 若数据分组有误或编号不正确，则返回ACK，编号和检验和

5. rdt3.0：具有比特差错的丢包信道
   - 丢包情况：数据分组丢失/数据分组应答丢失
   - 通过等待一定时间后重传解决
   - 发送方：
     - 被调用发送数据时，发送编号，数据，检验和，开始计时，进入等待应答状态
     - 当收到应答分组有误或编号不对，不操作
     - 若超时，重发并重新计时
     - 否则进入下一编号等待调用阶段
   - 接收方同rdt2.2

### 流水线rdt协议

rdt3.0的性能问题：停等协议

利用率：发送方实际忙于将数据送进信道那部分时间与发送时间的比 $U_{sender}={L/R\over RTT+L/R}​$

解决方法：流水线协议，允许发送多个分组而不用等待确认

- 增加序号范围
- 需要缓存多个分组
- 差错恢复：回退N步/选择重传

#### 回退N步

GBN（Go Back N step），也被称为滑动窗口协议

- 基序号：定义为最早未确认序号
- 下一个序号：最小未使用序号/下一个发送
- 分组分成4部分：已确认/已发送未确认/待发送/未能发送
- 缺点：出现错误便重传大量分组

##### 发送方

- 上层调用：若窗口未满，产生分组并发送，并更新变量（下一个序号），否则返回数据，让上一层稍后重试
- 收到应答：采用累积确认，表示此前的分组以及此分组都已接收正确，更新基序号，并考虑开始/停止计时器
- 超时事件：重传所有已发送未确认部分分组

##### 接收方

- 接收到的分组正确且按序：返回该序号的ACK，并获取数据
- 否则丢弃分组，返回最近按序接受分组的ACK

#### 选择重传

Selective Repeat，确认正确接收的分组而不管其是否有序，失序的被缓存至所有丢失分组接收到

##### 发送方

- 上层调用：同GBN
- 收到应答：分组标记为已接收，如果分组为最早未确认分组，则窗口右移至最小序号的未确认处，右移后出现未发送分组则发送分组
- 超时：每个分组一个计时器，超时后发送该分组

##### 接收方

- 窗口内的分组：回送ACK；若分组未收到过，缓存分组
  - 按序/序号为窗口基序号：窗口右移并交付该分组此前缓存的数据
  - 无序：只缓存
- 窗口前一个size范围中的分组：重发ACK （重要
- 其它情况忽略分组

##### 窗口范围选择

- 窗口范围选择不当时会出现无法判断分组为前面已确认的分组重传还是新的窗口里的分组
- 窗口长度必须小于或等于序号空间大小的一半：因为接收方只对窗口前一个窗口大小的分组进行重发ACK，即实际检测的范围为2N，只要确保检测范围内不出现重复即可

## TCP

面向连接的，发送数据前必须先握手，建立逻辑连接

- 全双工
- 点对点

### TCP连接

当数据通过套接字传递后，由TCP控制，进入发送缓存，TCP不时取出数据封装成报文段发送至下层网络层

- 最大报文长度MSS：受制于最大传输单元，要保证报文加上TCP/IP首部小于最大传输单元
- 最大传输单元MTU：最大链路层帧长度

#### 三次握手

建立TCP连接

1. 客户发送一个特殊TCP报文
2. 服务器返回特殊TCP报文响应
3. 客户用第三个特殊TCP报文作为响应，并承载有效载荷（即数据）

#### 组成

- 缓存：接受/发送
- 变量
- 套接字

### 报文结构

- 首部：典型为20字节，长度可变，无数据长度
  - 源端口+目的端口
  - 序号：用于rdt
  - 确认号：用于rdt
  - 4位首部长度：以字为单位
  - 6位标志字段
    - ACK
    - RST、SYN、FIN：连接建立与拆除
    - CWR、ECE：明确拥塞通告
    - PSH：数据应立即交换给上层
    - URG：存在紧急数据
  - 16位接收窗口rwnd
  - 16位检验和
  - 可选与变长的选项字段：用于协商最大报文长度/调节因子

- 数据

#### 序号和确认号

- 序号：该报文段首字节的字节流编号
- 确认号：期望收到的下一字节的序号
- 累积确认

### RTT估计与超时

如何设置超时时间：必须大于RTT往返时间

#### 往返时间的估计

- 样本RTT（SampleRTT）：某个报文从发出到收到确认的时间
- 任意时刻均可对已发送未确认的报文估计SampleRTT，但不为重传报文估计
- SampleRTT均值：EstimatedRTT
  - $$EstimatedRTT=(1-\alpha)EstimatedRTT+\alpha*SampleRTT，\alpha$$推荐为0.125
  - 每次测出的SampleRTT更新均值
  - 指数加权移动平均

- RTT变化：$$DevRTT=(1-\beta)DevRTT+\beta|SampleRTT-EstimatedRTT|$$

#### 超时间隔

大于EstimatedRTT但不应大太多

$$TimeoutInterval=EstimatedRTT+4DevRTT​$$

初始设为1秒，超时后加倍，EstimatedRTT更新后（接收到上层数据或受到ACK）更新超时间隔

### 可靠数据传输

网络层的尽力而为服务：不保证交付/按序/完整

TCP提供可靠数据传输服务，保证获取的数据流无损坏，无间隙，非冗余，按序

#### 发送方

- 从上层接收到数据：数据封装成报文，内含编号，发送，若定时器未开始，则开始计时
- 超时：重发最小序号未确认报文段，重启定时器
- 接收到ACK：与最早未确认的序号比较，若大于，则确定了一个或多个未确认报文段，更新最早未确认序号，重启/关闭定时器

- 超时间隔加倍：每次超时加倍超时时间间隔，接收到上层数据或收到ACK重新计算超时间隔

- 快速重传：相同数据受到3个**冗余ACK**后，表明已经丢失，马上重传

#### 接收方

产生ACK的建议

1. 期望序号报文到达，所有之前的序号已经确认：延迟的ACK，若等待时收到下一个按序报文，进入事件2
2. 期望序号报文到达，另一个按序报文等待ACK传输（未传输：立即发送累积ACK
3. 失序报文到达：发送冗余ACK，指示下一个期待序号
4. 填充报文到达：倘若报文起始于间隔的低端，立即发送ACK

#### 差错恢复

选择确认：混合GBN和SR

- 发送方只维护未确认最小序号和下一个发送序号和单个计时器
- 失序报文会被接受并缓存
- 超时只会重传一个报文段
- 有选择的确认失序报文：通过确认序号（预期报文）确认，而不是累积的最后一个正确且有效的序号

### 流量控制

- 流量控制：消除发送方使接收方缓存溢出的可能性
- 拥塞控制：防止IP网络拥塞而被遏制
- 接收窗口：发送方维护的变量，表示可用缓存空间大小

#### 服务

定义变量`LastByteRead`和``LastByteRevd`，接收而未被确认的字节小于等于缓存，而接受窗口rwnd大小等于缓存大小减去该部分字节

- 在每一轮报文传输中，接收方将自己的窗口大小放入到报文的接收窗口字段，由主机确保已发送未确认的数据量小于窗口大小
- 当接收方缓存已满时，窗口设置为0，此后发送方继续发送一个字节的报文段，直到缓存清空，窗口值改变

### TCP连接管理

#### 建立

1. 客户端发送TCP特殊报文段，不包含数据，SYN标志位置为1，报文段被成为SYN报文段，序号随机初始化
2. 服务器接收到SYN报文以后，分配TCP缓存和变量，发送允许连接的报文段。报文不包含数据，SYN位为1，确认号为初始序号+1，选择自己的初始序号，被称为SYNACK报文
3. 客户收到SYNACK报文后，分配缓存和变量，发送报文确认，报文可含数据，SYN为0

#### 关闭

1. 客户发出一个FIN位置1的报文
2. 服务器收到后发送确认报文
3. 服务器发送终止报文（FIN位为1
4. 客户收到后发送确认报文

#### 状态序列

P168

- 客户端
- 服务器端

#### 特殊情况

- 端口不匹配：主机发送特殊重置报文RST置为1

## 拥塞控制

网络拥塞：路由器缓存溢出

### 代价

1. 排队时延：当分组到达速率接近链路容量，巨大排队时延
2. 重传以补偿丢失的分组
3. 因为时延大而进行不必要的重传
4. 被丢弃的分组浪费了每个上游路由器转发使用的传输容量

### 控制方法

- 端对端：网络层不提供显式支持，由端系统观察网络行为来推断
- 网络辅助：路由器提供拥塞的显式反馈信息
  - 显式反馈：路由器直接发送分组
  - 标记或更新某个传输中分组的字段

### TCP拥塞控制

#### 关键

- 如何减慢传输速率：调节拥塞窗口大小cwnd，已发送未确认数据量不超过cwnd和rwnd的较小值
- 如何感知拥塞：丢包事件（超时/3次冗余
- 如何处理拥塞：如何调节cwnd

#### 指导性原则

- 丢包意味着拥塞，应降低传输速率
- 报文确认到达时，增加发送速率
- 带宽探测：逐渐增加速率直至丢包降低速率

#### TCP拥塞控制算法

P179

1. 慢启动：
   1. cwnd初值设为一个MSS的较小值，如1
   2. 每个到达的确认报文段，使cwnd加倍
   3. 慢启动以指数增长
   4. 超时将cwnd设为1并重新开始慢启动，将ssthresh设为cwnd/2
   5. 当cwnd的值到达或超过ssthresh时，进入拥塞避免状态
   6. 3个冗余ACK时进入快速恢复状态，将ssthresh设为cwnd/2，cwnd为cwnd/2+3
2. 拥塞避免状态
   1. 每收到一个确认增加一个MSS*MSS/cwnd
   2. 超时将cwnd设为1，将ssthresh设为cwnd/2进入慢启动状态
   3. 3个冗余ACK时进入快速恢复状态，将ssthresh设为cwnd/2，cwnd为cwnd/2
3. 快速恢复
   1. 导致缺失的每个冗余ACK，cwnd加一个MSS
   2. 丢失的报文到达时，进入拥塞避免状态
   3. 超时进入慢启动

忽略慢启动阶段：加性增，乘性减AIDM

#### 宏观描述

平均吞吐量$0.75*W\over RTT$，W为发生丢包时的窗口大小

考虑到窗口中报文会丢失$1.22*MSS\over RTT\sqrt L$，L为丢包率

### 公平性

- 每条连接都能得到相同份额的链路带宽，则认为拥塞控制机制是公平的
- TCP算法是公平的，最终会收敛于稳定的公平状态P183
- 实际中较小RTT的连接就会抢占到更多的带宽
- UDP是不公平的，甚至抢占TCP的带宽
- 并行TCP也会抢占带宽，从应用的角度来看不公平

### 明确拥塞公告ECN

数据报中两个比特用于ECN，指示路由器正经历拥塞

拥塞路由器为数据报首部设置ECN比特，接收方收到以后，通过在返回的ACK报文设置ECE位告知发送方拥塞，发送方收到应答后减半拥塞窗口，并在下一个传输的TCP报文段使用CWR（拥塞窗口缩减）比特设置