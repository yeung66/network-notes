# 3 运输层

## 多路复用与多路分解

网络层提供的主机间的交互扩展到主机上应用程序进程间的交互

- 多路分解：将运输层报文交付到正确的套接字
- 多路复用：主机从套接字收集数据块并封装首部生成报文，然后传递给网络层
- 多路复用要求：套接字有唯一标识（源端口号）/指示目的套接字（目的端口号）
- 端口号16比特，0-1023为周知端口号

### 无状态多路复用与多路分解

- 建立socket时自动分配未被使用端口号
- 通过bind方法可以为套接字关联一个端口号
- 报文到达对方主机后，根据目的端口号将报文交付给相应套接字
- 每个套接字由一个（目的IP，目的端口）标识

### 面向连接多路复用与多路分解

- 每个套接字由一个（源IP，源端口，目的IP，目的端口）标识，报文根据全部4个值来定向到套接字
- 每个套接字与一个进程/线程相关联

## UDP

运输协议能做的最少工作：复用/分解+差错检测

进程获得数据，附加端口号等字段，交给网络层，对方收到后根据端口号交给相应的进程

### 使用原因

- 对于发送什么以及何时发送应用层控制更为精细
  - UDP：只用传输数据给UDP马上发送
  - 而TCP具有拥塞控制机制/实现可靠交付可能需要重复发送报文
  - 实时应用：满足最小的发送速率
- 无须建立连接：避免建立连接的时延
- 无连接状态
- 首部开销小：8字节而TCP20字节

### 报文结构

- 首部：32*2比特
  - 源端口号
  - 目的端口号
  - 长度：首部+数据
  - 检验和
- 数据

### 检验和

所有数据16比特按进位相加，溢出回卷，最后的和的反码为检验和

- 接收时将所有数据以及检验和加起来，判断是否为0xffff

#### 端对端原则

与较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或者几乎没有价值的

- 因为端对端数据传输需要提供差错检测，UDP必须在运输层的基础上提供差错检测

## 可靠数据传输原理

服务抽象：数据可以通过一条可靠信道传输，传输数据比特不会损坏或丢失，且按顺序交付

实现：可靠数据传输协议

### 构造可靠数据传输协议rdt

1. rdt1.0：信道完全可靠，数据封装成分组后直接传输，接受分组后直接获取数据进行分发
2. rdt2.0：具有比特差错 自动重传协议ARQ——接收到信息后给予反馈，有问题则重新传输
   - 协议功能：
     - 差错检测
     - 接受方反馈：ACK NAK
     - 重传
   - 停等协议：等待应答时不能发送新数据
   - 问题：应答信号也可能有差错
     - 解决：差错询问/差错恢复/rdt2.1
3. rdt2.1：为解决2.0中应答信号可能出错，采用非ACK则重复发送，并引入编号解决冗余分组
   - 发送方：
     - 被调用发送数据时，发送编号，数据，检验和，进入等待应答状态
     - 当收到应答分组有误或为NAK则重发
     - 否则进入下一编号等待调用阶段
   - 接收方：
     - 当接受到数据分组没有错误且编号为0时，获取数据，返回ACK，进入下一编号状态
     - 若数据分组有误，则返回NAK和检验和
     - 若数据没有错误但编号异常，则返回ACK和检验和，不获取数据
4. rdt2.2：无NAK版本的2.1，通过判断应答分组是否ACK且编号正确判断需否重发
   - 发送方：
     - 被调用发送数据时，发送编号，数据，检验和，进入等待应答状态
     - 当收到应答分组有误或编号不对则重发
     - 否则进入下一编号等待调用阶段
   - 接收方：
     - 当接受到数据分组没有错误且编号为0时，获取数据，返回ACK与编号0，进入下一编号状态
     - 若数据分组有误或编号不正确，则返回ACK，编号和检验和

5. rdt3.0：具有比特差错的丢包信道
   - 丢包情况：数据分组丢失/数据分组应答丢失
   - 通过等待一定时间后重传解决
   - 发送方：
     - 被调用发送数据时，发送编号，数据，检验和，开始计时，进入等待应答状态
     - 当收到应答分组有误或编号不对，不操作
     - 若超时，重发并重新计时
     - 否则进入下一编号等待调用阶段
   - 接收方同rdt2.2

### 流水线rdt协议

rdt3.0的性能问题：停等协议

利用率：发送方实际忙于将数据送进信道那部分时间与发送时间的比 $U_{sender}={L/R\over RTT+L/R}$

解决方法：流水线协议，允许发送多个分组而不用等待确认

- 增加序号范围
- 需要缓存多个分组
- 差错恢复：回退N步/选择重传

#### 回退N步

GBN（Go Back N step），也被称为滑动窗口协议

- 基序号：定义为最早未确认序号
- 下一个序号：最小未使用序号/下一个发送
- 分组分成4部分：已确认/已发送未确认/待发送/未能发送
- 缺点：出现错误便重传大量分组

##### 发送方

- 上层调用：若窗口未满，产生分组并发送，并更新变量（下一个序号），否则返回数据，让上一层稍后重试
- 收到应答：采用累积确认，表示此前的分组以及此分组都已接收正确，更新基序号，并考虑开始/停止计时器
- 超时事件：重传已发送未确认部分分组

##### 接收方

- 接收到的分组正确且按序：返回该序号的ACK，并获取数据
- 否则丢弃分组，返回最近按序接受分组的ACK

#### 选择重传

Selective Repeat，确认正确接收的分组而不管其是否有序，失序的被缓存至所有丢失分组接收到

##### 发送方

- 上层调用：同GBN
- 收到应答：分组标记为以接收，如果分组为最早未确认分组，则窗口右移至最小序号的未确认处，右移后出现未发送分组则发送分组
- 超时：每个分组一个计时器，超时后发送该分组

##### 接收方

- 窗口内的分组：回送ACK；若分组未收到过，缓存分组
  - 按序/序号为窗口基序号：窗口右移并交付该分组此前缓存的数据
  - 无序：只缓存
- 窗口前一个size范围中的分组：重发ACK （重要
- 其它情况忽略分组

##### 窗口范围选择

- 窗口范围选择不当时会出现无法判断分组为前面已确认的分组重传还是新的窗口里的分组
- 窗口长度必须小于或等于序号空间大小的一半：因为接收方只对窗口前一个窗口大小的分组进行重发ACK，即实际检测的范围为2N，只要确保检测范围内不出现重复即可

## TCP

面向连接的，发送数据前必须先握手，建立逻辑连接

- 全双工
- 点对点